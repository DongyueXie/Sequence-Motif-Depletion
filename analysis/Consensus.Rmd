---
title: "Consensus"
author: "Dongyue Xie"
date: "July 4, 2017"
output: html_document
---

<!-- The file analysis/chunks.R contains chunks that define default settings
shared across the workflowr files. -->
```{r read-chunk, include=FALSE, cache=FALSE}
knitr::read_chunk("chunks.R")
```

<!-- Update knitr chunk options -->
```{r knitr-opts-chunk, include=FALSE}
```

<!-- Insert the date the file was last updated -->
```{r last-updated, echo=FALSE, results='asis'}
```

<!-- Insert the code version (Git commit SHA1) if Git repository exists and R
 package git2r is installed -->
```{r code-version, echo=FALSE, results='asis'}
```

<!-- Add your analysis here -->





The original IUPAC code is gotten in the way that one finds the bases that has larger frequency than the background probability(default $0.25$), then corresponds them to the IUPAC code table. There are some problems with this method. Firstly, if the frequencies of $A,C,G,T$ at a position are $(0.28,0.24,0.24,0.24)$, then the code would be A for the position. However, it seems that an N is more appropriate which means any base. Secondly, if the frequencies are $(0.35,0.35,0.24,0.06)$, then the code would be $M(A$ or $C)$ for the position. But a depletion in $T$ may be a better representation. Also, to use $(AC)$ representing $A$ or $C$ is more straightforward than introducing extra letters. 

#The method
Here, an improved IUPAC nucleotide code is proposed so that the code could give more information about the enrichment and depletion of bases. We first divide all possible frequencies into the following categories: 

1. Any base,  denoted by $N$.
2. Enrichment in one base,  denoted by the base name.
3. Enrichments in two bases, denote by the two base names with a bracket. The first one has larger frequency.
4. Depletion in one base, denoted by the base name but in lowercase.
5. Depletion in one base and an enrichment in another, denoted by the base names(case sensitive) with bracket.

Then define three kinds of vectors whose length is 3 and the elements sum to 1:

1. $V_1$ : One large elements and the others are small, e.g: $(1,0,0)$, $(0.8,0.1,0.1)$
2. $V_2$ : Two large elements and the other one is small, e.g: $(0.5,0.5,0)$, $(0.45,0.45,0.1)$
3. $V_3$ : Equally large elements, e.g:$(1/3,1/3,1/3)$

We sort the base frequencies at a position descendingly and divide it into two parts, the largest three and the smallest three(both are ordred descendingly), then get the distance between the each part(scaled, sum to 1) and the three kinds of vectors defined above. For example, $(1,0,0)$, $(0.5,0.5,0)$, $(1/3,1/3,1/3)$. For the $N$ case, both of the two parts should have smallest diatance to $(1/3,1/3,1/3)$. And the for the "one enrichment" case, the largest three should have the smallest distance to $(1,0,0)$, etc. So according to the distances, we could determine which category the position belongs to and then assign the corresponding code. I take $A$ and $T$ as examples to illuastrate the results. If the largest three is closest to $(1,0,0)$ and the smallest three is closest to $(1/3,1/3,1/3)$, then the code should be $A$. In the following table, I denote the case as "$(1,0,0),(0.5,0.5,0) - A$". Below are examples of different combinations:

1. $(1,0,0),(1,0,0) - A$
2. $(1,0,0),(0.5,0.5,0) - At$
3. $(1,0,0),(1/3,1/3,1/3) - A$
4. $(0.5,0.5,0),(1,0,0) - AT$
5. $(0.5,0.5,0),(0.5,0.5,0) - t$
6. $(0.5,0.5,0),(1/3,1/3,1/3) - AT$
7. $(1/3,1/3,1/3),(1,0,0) - AT$
8. $(1/3,1/3,1/3),(0.5,0.5,0) - t$
9. $(1/3,1/3,1/3),(1/3,1/3,1/3) - N$  

Note that the cases 1,5,6,7 may not be straightforward to understand. Here are some brief explanations. Case 1: the largest one is much larger than the others. Case 5: the first three are larger than the last one. Case 6,7: the first two are larger than the last two. Further, $(0.9,0.05,0.05,0)$ would be classified as case 2 however we want it to be case 1. To avoid this, we require that the difference between the smallest and the second smallest should be at least 0.12.  

There are two types of distance function. The first type is the measure of the distance between two discrete distributions. For example, Kullback-Leibler divergence, Jensenā-Shannon divergence, Bhattacharyya distance. The second type is the vector norm. For example, $L^1$ norm ,$L^2$ norm, infinity norm.

So for each different choice of $V_1,V_2,V_3$ and distance function, we would have one code for the sequence. So in total, there are $n_{v_1}*n_{v_2}*n_{v_3}*n_{dis}$ codes. To make the result robust to these choices, we take the mode of the code at the each position. And if there are two codes that happen more than $40\%$ of the time, we report both. For example, $A$ happens 3 times and $At$ happens 4 times out of total 7 times, then the code is given by $[A-At]$

#Application

In the implementation, we chose $V_1=(0.9,0.05,0.05),(0.85,0.075,0.075),(0.8,0.1,0.1),(0.75,0.125,0.125),(0.7,0.15,0.15)$, $V_2=(0.5,0.5,0),(0.475,0.475,0.05),(0.45,0.45,0.1)$, $V_3=(1/3,1/3,1/3)$. 

The distance functions are symmetric Kullback-Leibler divergence, Jensenā-Shannon divergence, Bhattacharyya distance, $L^1$ norm, $L^2$ norm, infinity norm. An additional distance function is the average of the above six distance functions but it's not counted for the final code.

Then we apply the code to the depletion data we are interested in and compare them with the IUPAC code from atSNP package.

```{r,include=FALSE}
library(JASPAR2014)
library(TFBSTools)
library(Logolas)
library(ggplot2)
library(plyr)
color_profile = list("type" = "per_row", 
                     "col" = RColorBrewer::brewer.pal(4,name ="Spectral"))
```

```{r,echo=FALSE}
# a function scale the vector to be in (0,1)
scale1=function(x){return(x/sum(x))}

# a function to get the symmetric kl divergence 
sym_KL=function(p,q){
  if(sum(p==0)!=0){p=scale1(p+0.001)}
  if(sum(q==0)!=0){q=scale1(q+0.001)}
  return(mean(c(sum(p*log(p/q,2)),sum(q*log(q/p,2)))))
}

# Bhattacharyya distance
Bdist=function(p,q){
  if(sum(p==0)!=0){p=scale1(p+0.001)}
  if(sum(q==0)!=0){q=scale1(q+0.001)}
  return(-log(sum(sqrt(p*q))))
}

# Jensenâ-Shannon divergence
JSdist=function(p,q){
  if(sum(p==0)!=0){p=scale1(p+0.001)}
  if(sum(q==0)!=0){q=scale1(q+0.001)}
  m=(p+q)/2
  return(sum(p*log(p/m,2))/2+sum(q*log(q/m,2))/2)
}

#Euclidean distance
norm2=function(p,q){
  return(sqrt(sum((p-q)^2)))
}

#$L^1$ norm distance
norm1=function(p,q){return(sum(abs(p-q)))}

#inf norm
norminf=function(p,q){return(max(abs(p-q)))}

#a fucntion get the average distance over several distance functions
ave_dis=function(p,q){
  return((sym_KL(p,q)+JSdist(p,q)+Bdist(p,q)+norm1(p,q)+norm2(p,q)+norminf(p,q))/6)
}

#mode for a charactor
Mode <- function(x) {
  ux <- unique(x)
  #if(max(tabulate(match(x, ux)))/length(x)>=0.6){re=(ux[which.max(tabulate(match(x, ux)))])}
  if(sum(tabulate(match(x, ux))/length(x)>=0.4)==2){re=ux[which(tabulate(match(x, ux))>=(length(x)*0.4))]}else{
   #re=(ux[which.max(tabulate(match(x, ux)))])
   re=ux[which(tabulate(match(x, ux))==max(tabulate(match(x, ux))))] 
  }
  return(re)
}

#
code_pos2=function(f,bases,disfunc,one,two){
  based=tolower(bases)
  three=c(1/3,1/3,1/3)
  mat=cbind(one,two,three)
  #get the top three and the bottom three
  top3=sort(f,decreasing = T)[-4]
  bot3=sort(f,decreasing = T)[-1]
  #check the dist of top3&bottom3 with one two three
  if(disfunc=='KL'){func=sym_KL}
  if(disfunc=='JS'){func=JSdist}
  if(disfunc=='Bdis'){func=Bdist}
  if(disfunc=='onenorm'){func=norm1}
  if(disfunc=='twonorm'){func=norm2}
  if(disfunc=='infnorm'){func=norminf}
  if(disfunc=='ave_dis'){func=ave_dis}
  dis_top=apply(mat,2,func,q=scale1(top3))
  dis_bot=apply(mat,2,func,q=scale1(bot3))
  #find the which case it belongs to
  case=factor(which.min(dis_top)):factor(which.min(dis_bot))
  
  #check the difference between smallest one &second smallest one.
  dif34=sort(f,decreasing = T)[3]-sort(f,decreasing = T)[4]
  
  #assign code
  if(case=='1:1'|case=='1:3'|(case=='1:2' & dif34<0.12)){cd=bases[which.max(f)]}
  if(case=='1:2' & dif34>=0.12){cd=paste('(',bases[which.max(f)],based[which.min(f)],')',sep = '')}
  if(case=='2:1'|case=='2:3'|case=='3:1'|(case=='3:2' & dif34<0.12)){cd=paste('(',bases[sort(f,index.return=T,decreasing = T)$ix[1]],bases[sort(f,index.return=T,decreasing = T)$ix[2]],')',sep = '')}
  if((case=='3:2' & dif34>=0.12)|case=='2:2'){cd=based[which.min(f)]}
  if(case=='3:3'){cd='N'}
  return(cd)
  #return(case)
  #return(list(dis=cbind(dis_top,dis_bot),case=case,code=cd))
  #return(c(cd,case))
}

#a function for averaging the codes from different distance function
code_pos_ave=function(f,bases,one,two){
  allcode=c()
  for(func in c('KL','JS','Bdis','onenorm','twonorm','infnorm','ave_dis' )){
    allcode=c(allcode,code_pos2(f,bases,func,one,two))
  }
  if(length(Mode(allcode))==1){return(Mode(allcode))}else{
    return(paste('[',paste(Mode(allcode),collapse = '-'),']',sep = ''))
  }
}

# a function to get the code for a motif
motifcode2=function(pwm,disfunc,one,two,sep=TRUE){
  if(length(rownames(pwm))!=4){bases=c('A','C','G','T')}else{bases=rownames(pwm)}
  if(sep){
    if(disfunc!='ave_code'){
    return(apply(pwm,2,code_pos2,bases=bases,disfunc=disfunc,one=one,two=two))
  }else{return(apply(pwm,2,code_pos_ave,bases=bases,one=one,two=two))}
  }else{
    if(disfunc!='ave_code'){
    return(paste(apply(pwm,2,code_pos2,bases=bases,disfunc=disfunc,one=one,two=two),collapse = ''))
  }else{return(paste(apply(pwm,2,code_pos_ave,bases=bases,one=one,two=two),collapse = ''))}
  }
  }
  
cmode=function(vec){
   if(length(Mode(vec))==1){return(Mode(vec))}else{
    return(paste('[',paste(Mode(vec),collapse = '-'),']',sep = ''))
  }
 }
 
 # a function that take the mode of the code over differetn choices of one and two prob vectors.
 Getmotif=function(pwm){
   results=c()
 for(one in list(c(0.9,0.05,0.05),c(0.85,0.075,0.075),c(0.8,0.1,0.1),c(0.75,0.125,0.125),c(0.7,0.15,0.15))){
   for(two in list(c(0.5,0.5,0),c(0.475,0.475,0.05),c(0.45,0.45,0.1))){
     for (ff in c('KL','JS','Bdis','onenorm','twonorm','infnorm')){
      results=rbind(results,motifcode2(pwm,ff,one,two)) 
     }
   }
 }
   
 return(paste(apply(results,2,cmode),collapse = ''))
 }
```

```{r,echo=FALSE}
#A function to get the PWM given PFM:
getpwm=function(pfm,bg=0.25){
  pfm=as.matrix(pfm)
  pseudo=sqrt(dim(pfm)[2])/4
  pwm=apply((pfm+pseudo),2,scale1)
  rownames(pwm)=c('A','C','G','T')
  colnames(pwm)=1:dim(pfm)[2]
  return(pwm)
}
  
#A function to find the position with perfect depletion
#If the counts in pfm is smaller than 20, then discard the pfm and set pwm=NA
getdep=function(pwm){
  if(sum(is.na(pwm))==1){d=0}else{
  ic=neg_ic_computer(pwm)
  maxneg=apply(ic$ic_neg,2,max)
  max2=apply(rbind(ic$ic_pos,ic$ic_neg),2, function(x) sort(x,T)[2])
  d=maxneg-max2
  d[is.na(d)]=0
  }
  return(d)
}

# A function to get the sequence motif.
GetIUPACSequence = function(pwm, prob = 0.25) {
  iupac.table =
    c(".", "A", "C", "M", "G", "R", "S", "V", "T", "W", "Y", "H", "K", "D", "B", "N")
  iupac.value = t((pwm >= prob)) %*% c(1, 2, 4, 8) + 1
  return(paste(iupac.table[iupac.value], collapse = ""))
}

#function to read txt files:
#functions to read the data from ENCODE, http://compbio.mit.edu/encode-motifs/motifs.txt
#Modified from atSNP package
myStrSplit <- function(x, split) {
  ret <- list(seq_along(x))
  for(i in seq_along(x)) {
    ret[[i]] <- x[i]
    for(sp in split) {
      ret[[i]] <- unlist(strsplit(ret[[i]], sp))
      ret[[i]] <- ret[[i]][nchar(ret[[i]]) > 0]
      if(length(ret[[i]]) == 0)
        break
    }
  }
  return(ret)
}


LoadMotifLibrary <- function(filename, tag = "MOTIF", transpose = FALSE, field = 2, sep = c("\t", " "), skipcols = 0, skiprows = 2, pseudocount = 0) {
  lines <- readLines(filename)
  motifLineNums <- grep(tag, lines)
  if(length(myStrSplit(lines[motifLineNums[1]], sep)[[1]]) >= field) {
    motifnames <-
      sapply(myStrSplit(lines[motifLineNums], sep), function(x) x[field])
  } else {
    motifnames <-
      sapply(myStrSplit(lines[motifLineNums], sep), function(x) x[field])
  }
  allmats <- as.list(seq_along(motifnames))
  
  for(matrixId in seq_along(motifLineNums)) {
    motifLineNum <- motifLineNums[matrixId] + skiprows
    if(!transpose) {
      pwm <- NULL
      nrows <- 0
      tmp <- myStrSplit(lines[nrows + motifLineNum], split = sep)[[1]]
      tmp <- tmp[nchar(tmp) > 0]
      while(length(tmp) >= 4 + skipcols) {
        tmp <- as.numeric(tmp[skipcols + seq(4)])
        if(sum(is.na(tmp)) == 0) {
          pwm <- rbind(pwm, tmp)
        }
        nrows <- nrows + 1
        tmp <- myStrSplit(lines[nrows + motifLineNum], split = sep)[[1]]
        tmp <- tmp[nchar(tmp) > 0]
      }
    } else {
      nrows <- 4
      if(skipcols == 0) {
        pwm <-
          matrix(as.numeric(unlist(myStrSplit(lines[seq(nrows) + motifLineNum - 1], split = sep))), ncol = 4)
      } else {
        pwm <-
          matrix(as.numeric(unlist(sapply(myStrSplit(lines[seq(nrows) + motifLineNum - 1], split = sep), function(x) x[-seq(skipcols)]))), ncol = 4)
      }
    }
    
    pwm = t(pwm)
    #check if the counts of pfm are larger than 20.If smaller than 20, set as NA.
    if (sum(pwm[,1])<20){
      if(sum(pwm[,1])<=2){
      pwm <- pwm + pseudocount
      pwm <- pwm / apply(pwm, 2, sum)
      rownames(pwm) <- c('A','C','G','T')
      colnames(pwm) = 1:dim(pwm)[2]
    }else{pwm=NA}
    }else{pwm=getpwm(pwm)}
    allmats[[matrixId]] <- pwm
  }
  names(allmats) <- motifnames
  return(allmats)
}

#A function that takes PWM list as input and then output depletion positions.
#'@ alpha: threshhold of perfect depletion
#'@ pwm: list of PWMs
depletion=function(pwm,alpha=0.1077487){
  scores=lapply(pwm,getdep)
  cc=c('A','C','G','T')
  dlist=list()
  for (i in 1:length(pwm)){
    if (sum(scores[[i]]>=alpha)!=0){
      position=which(scores[[i]]>=alpha)
      npos=dim(pwm[[i]])[2]
      value=scores[[i]][position]
      mat=pwm[[i]]
      base=cc[apply(cbind(mat[,position]),2,which.min)]
      nbrleft1=substring(GetIUPACSequence(pwm[[i]]),
                         position-1,position-1)
      nbrright1=substring(GetIUPACSequence(pwm[[i]]),
                          position+1,position+1)
      name=names(pwm[i])
      ID=i
      sublist=list(ID=ID,position=position,npos=npos,base=base,value=value,
                   mat=mat,nbrleft1=nbrleft1,nbrright1=nbrright1)
      dlist[[name]]=sublist
    }
  }
  return(dlist)
}
```

```{r,warning=FALSE,echo=FALSE}
#extract all pwms from JASPAR 2014
opts = list()
PFMlist = getMatrixSet(JASPAR2014,opts)
#length(PFMlist)
PWMJaspar=lapply(PFMlist,function(x) if(sum(as.matrix(x)[,1])>=20){getpwm(x)}else{NA})

#extract all pwms from encode (from atSNP)
PWMencode=LoadMotifLibrary("http://compbio.mit.edu/encode-motifs/motifs.txt", tag = ">",transpose = FALSE, field = 1, sep = c("\t", " ", ">"), skipcols = 1, skiprows = 1, pseudocount = 0.001)

#extract all pwms from HOCOMOCO
PWMHuman=LoadMotifLibrary('http://hocomoco.autosome.ru/final_bundle/HUMAN/mono/HOCOMOCOv10_HUMAN_mono_jaspar_format.txt',tag='>',field = 1,sep = c("\t", " ", ">"), transpose = T,skipcols = 0, skiprows = 1)
PWMMouse=LoadMotifLibrary('http://hocomoco.autosome.ru/final_bundle/MOUSE/mono/HOCOMOCOv10_MOUSE_mono_jaspar_format.txt',tag='>',field = 1,sep = c("\t", " ", ">"), transpose = T,skipcols = 0, skiprows = 1)

DepJaspar=depletion(PWMJaspar,alpha = 0.2)
DepEncode=depletion(PWMencode)
DepHuman=depletion(PWMHuman)
DepMouse=depletion(PWMMouse)
```

Dimer: 

IRF family. Mouse.

The IUPAC code is given firstly followed by our code and the pwm.
```{r}
GetIUPACSequence(DepMouse[[11]]$mat)
Getmotif(DepMouse[[11]]$mat)
DepMouse[[11]]$mat

GetIUPACSequence(DepMouse[[12]]$mat)
Getmotif(DepMouse[[12]]$mat)
DepMouse[[12]]$mat

GetIUPACSequence(DepMouse[[13]]$mat)
Getmotif(DepMouse[[13]]$mat)
DepMouse[[13]]$mat
```

SOX family. Mouse.

```{r}
GetIUPACSequence(DepMouse[[27]]$mat)
Getmotif(DepMouse[[27]]$mat)
DepMouse[[27]]$mat

GetIUPACSequence(DepMouse[[28]]$mat)
Getmotif(DepMouse[[28]]$mat)
DepMouse[[28]]$mat
```

EFB1 family:
```{r}
for (i in grep('EBF1',names(DepEncode))){
print(names(DepEncode[i]))
print(GetIUPACSequence(DepEncode[[i]]$mat))
print(Getmotif(DepEncode[[i]]$mat))
print(DepEncode[[i]]$mat)
}
```


## Session information

<!-- Insert the session information into the document -->
```{r session-info}
```
